#!/bin/bash

source orkhideya
ork_include stdlib

function if_root
{
   ork_configpath "if"
   return 0
}

function if_class_root
{
   ork_pathcat "$(if_root)" "$ORK_IF_CLASS_PATH"
   return 0
}

function if_dev_root
{
   ork_pathcat "$(if_root)" "$ORK_IF_DEV_PATH"
   return 0
}

function if_class_path
{
   local _class="$1"
   ork_pathcat "$(if_class_root)" "$_class"
   return 0
}

function if_dev_path
{
   local _dev="$1"
   ork_pathcat "$(if_dev_root)" "$_dev"
   return 0
}

function if_class_exists
{
   local _class="$1"
   test -d "$(if_class_path "$_class")"
   return $?
}

function if_dev_exists
{
   local _dev="$1"
   test -d "$(if_dev_path "$_dev")"
   return $?
}

function if_class_new
{
   local _class="$1"
   local _args="${@:2}"
   ! if_class_exists "$_class" && return 1

   local _class_path="$(if_class_path "$_class")"

   local _class_create="$_class_path/create"
   [ ! -x "$_class_create" ] && return 2

   local _new_device="$($_class_create "$_args")"
   if [ "$?" != "0" ]; then return 3; fi

   if_dev_exists "$_new_device" && return 4

   local _dev_file="$_dev_path/class"
   stdlib_forcepath "$_dev_file"

   echo "$_class" > "$_dev_file"
   echo "$_new_device"

   return 0
}

function if_interface_unique_name
{
   local _root="$1"
   local _suffix="0"
   local _new_name="${_root}${_suffix}"

   while if_interface_exists "$_new_name"; do
      _suffix="$(($_suffix+1))"
      _new_name="${_root}${_suffix}"
   done

   echo $_new_name
   return 0
}

function if_interface_exists
{
   local _interface="$1"
   test -n "$(ifconfig -a | grep "^${_interface}:")"
   return $?
}

function if_interface_isup
{
   local _interface="$1"

   if ! if_interface_exists "$_interface"; then return 1; fi

   ifconfig -s | tail -n+2 | grep -q "^${_interface}"
   return $?
}

function if_interface_isdown
{
   local _interface="$1"
   ! if_interface_isup "$_interface"
   return $?
}

function if_interface_downup
{
   local _interface="$1"
   local _downup="$2"

   if [ "$_downup" != "down" -a "$_downup" != "up" ]; then
      return 1
   fi

   ifconfig "$_interface" $_downup
   return $?
}

function if_interface_down
{
   local _interface="$1"
   if_interface_downup "$_interface" down
   return $?
}

function if_interface_up
{
   local _interface="$1"
   if_interface_downup "$_interface" up
   return $?
}

function if_interface_haslink
{
   local _interface="$1"
   local _carrier="/sys/class/net/$_interface/carrier"

   if ! ( if_interface_exists "$_interface" ); then return 1; fi
   test -r "$_carrier" -a "$(cat "$_carrier" 2>/dev/null)" == "1"
   return $?
}

function if_interface_address_canacquire
{
   local _family="$1"

   case "$_family" in
      unix|inet|inet6|ax25|netrom|rose|ipx|ddp|ec|ash|x25|netmask|broadcast)
         return 0
         ;;
      *)
         return 1
         ;;
   esac
}

function if_interface_address_get
{
   local _interface="$1"
   local _family="$2"

   if ! if_interface_address_canacquire "$_family"; then return 1; fi
   if ! if_interface_exists "$_interface"; then return 2; fi

   ifconfig "$_interface" | grep -o -P "$_family\s+.*" | awk '{ print $2 }'
   if [ "$?" != "0" ]; then return 3; fi
   return 0
}

function if_interface_address_set
{
   local _interface="$1"
   local _family="$2"
   local _address="$3"

   if ! if_interface_address_canacquire "$_family"; then return 1; fi
   if ! if_interface_exists "$_interface"; then return 2; fi

   ifconfig "$_interface" "$_family" "$_address"
   if [ "$?" != "0" ]; then return 3; fi
   return 0
}

function if_interface_link_wait
{
   local _device="$1"

   if ! if_interface_exists "$_device"; then return 1; fi
   if ! if_interface_isup "$_device"; then return 2; fi

   local _timeout="0"

   while [ "$_timeout" -lt "$ORK_IF_LINK_TIMEOUT" ]; do
      if if_interface_haslink "$_device"; then break; fi
      sleep 1
      _timeout="$(($_timeout+1))"
   done

   if [ "$_timeout" == "$ORK_IF_LINK_TIMEOUT" ]; then
      return 3
   fi

   return 0
}

ORK_IF_LINK_TIMEOUT="30"
ORK_IF_DEV_PATH="dev"
ORK_IF_CLASS_PATH="class"

ork_reconfigure "if"
