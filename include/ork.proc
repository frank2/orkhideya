#!/bin/bash

source orkhideya
ork_include stdlib

function proc_root
{
   ork_configpath "proc"
   return 0
}

function proc_pid_root
{
   ork_pathcat "$(ork_pathroot tmp)" "$ORK_PROC_PID_PATH"
   return 0
}

function proc_template_root
{
   ork_pathcat "$(proc_root)" "$ORK_PROC_TEMPLATE_PATH"
   return 0
}

function proc_silent
{
   "$@" &>/dev/null
   return $?
}

function proc_is_running
{
   _pid="$1"
   test -n "$(ps -p "$_pid" | tail -n+2)"
   return $?
}

function proc_kill
{
   _pid="$1"
   ! proc_is_running "$_pid" && return 1

   proc_silent kill -9 "$_pid"
   if [ "$?" != "0" ]; then return 2; fi
   return 0
}

function proc_timed_kill
{
   _pid="$1"
   _timeout="$2"

   sleep $_timeout && proc_kill "$_pid"
   return $?
}

function proc_template_exists
{
   local _template="$1"
   test -e "$(proc_template_root)/$(stdlib_pathify "$_template")"
   return $?
}

function proc_template_command
{
   local _template="$1"
   local _args="${@:2}"

   ! proc_template_exists "$_template" && return 1
   local _file="$(stdlib_filesearch "$(proc_template_root)" "$(stdlib_pathify "$_template")" "$ORK_PROC_TEMPLATE_RUN_FILE")"

   if [ ! -x "$_file" ]; then return 2; fi

   local _commandline="$("$_file" $_args)"
   if [ -z "$_commandline" ]; then return 3; fi

   echo "$_commandline"
   return 0
}

function proc_template_kill
{
   local _template="$1"
   local _pid="$2"
   local _args="${@:3}"

   ! proc_template_exists "$_template" && return 1
   local _file="$(stdlib_filesearch "$(proc_template_root)" "$(stdlib_pathify "$_template")" "$ORK_PROC_TEMPLATE_KILL_FILE")"

   if [ ! -x "$_file" ]; then return 1; fi

   "$_file" "$_pid" $_args
   if [ "$?" != "0" ]; then return 2; fi
   return 0
}

function proc_template_has_arg
{
   local _arg="$1"
   local _args="${@:2}"

   echo "$_args" | grep -E -q "([[:space:]]+$_arg[[:space:]]+|[[:space:]]+$_arg\$|^$_arg[[:space:]]+|^$_arg\$)"
   return $?
}

function proc_label_path
{
   local _label="$1"
   echo "$(proc_pid_root)/$_label"
   return 0
}

function proc_label_exists
{
   local _label="$1"

   test -e "$(proc_label_path "$_label")"
   return $?
}

function proc_label_pid
{
   local _label="$1"
   ! proc_label_exists "$_label" && return 1

   local _procpath="$(proc_label_path "$_label")"
   ! test -r "$_procpath/pid" && return 2

   cat "$_procpath/pid"

   [ "$?" != "0" ] && return 3
   return 0
}

function proc_label_is_running
{
   local _label="$1"

   ! proc_label_exists "$_label" && return 1
   ! proc_is_running "$(proc_label_pid "$_label")" && return 2
   return 0
}

function proc_label_spawn
{
   local _label="$1"
   local _commandline="${@:2}"
   [ -z "$_label" ] && return 1

   local _pidpath="$(proc_pid_root)/$_label"
   [ -z "$_pidpath" ] && return 2
   [ -d "$_pidpath" ] && return 3 # pid by this label exists already

   local _pidfile="$(stdlib_forcepath "$_pidpath/pid")"

   stdout_warning "Executing: $(stdout_color_wrap main-focused "$_commandline")"

   $_commandline &
   sleep 1

   _resulting_pid="$(ps kstart_time ax | sort -r | grep "$_commandline" | grep -v grep | head -n1 | awk '{ print $1 }')"

   if [ -z "$_resulting_pid" ]; then 
      stdout_error "Fork failure."

      proc_silent rm -rf "$(stdlib_cdup $_pidpath)" 
      return 4
   fi

   echo "$_resulting_pid" > "$_pidfile"
   return 0
}

function proc_label_kill
{
   local _label="$1"
   local _args="${@:2}"
   ! proc_label_exists "$_label" && return 1

   local _procpath="$(proc_label_path "$_label")"
   local _pid="$(proc_label_pid "$_label")"
   [ -z "$_pid" ] && return 2

   if [ -r "$_procpath/template" ]; then
      local _template="$(cat "$_procpath/template")"

      ! proc_template_exists && return 3
      ! proc_template_kill "$_template" "$_pid" $_args && return 4
   fi

   if proc_label_is_running "$_label"; then
      local _pid="$(proc_label_pid "$_label")"
      [ -n "$_pid" ] && proc_silent kill -9 "$_pid"
   fi 

   proc_silent rm -rf "$_procpath"
   return 0
}

function proc_label_template_exec
{
   local _label="$1"
   local _template="$2"
   local _args="${@:3}"

   _commandline="$(proc_template_command "$_template" $_args)"
   [ -z "$_commandline" ] && return 1

   proc_label_spawn "$_label" "$_commandline"
   [ "$?" != "0" ] && return 2

   local _template_file="$(stdlib_forcepath "$(proc_label_path "$_label")/template")"
   echo $_template > "$_template_file"

   return 0
}

ORK_PROC_PID_PATH="pid"
ORK_PROC_TEMPLATE_PATH="templates"
ORK_PROC_TEMPLATE_RUN_FILE="run"
ORK_PROC_TEMPLATE_KILL_FILE="kill"
